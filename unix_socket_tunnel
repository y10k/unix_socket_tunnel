#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'io/wait'
require 'logger'
require 'optparse'
require 'socket'

STDLOG = Logger.new(STDOUT)

def ping_process(pid)
  begin
    Process.kill(0, pid)
    true
  rescue SystemCallError
    STDLOG.info("process lost: #{pid}")
    STDLOG.debug($!)
    false
  end
end

def start_tunnel(socket1, addr1, socket2, addr2, chunk_bytes: 1024*8)
  Thread.new{
    STDLOG.info("start tunnel: #{addr1} -> #{addr2}")
    begin
      while (true)
        STDLOG.info("tunnel read: #{addr1} max #{chunk_bytes} bytes")
        data = socket1.readpartial(chunk_bytes)
        STDLOG.info("tunnel write: #{addr2} #{data.bytesize} bytes")
        socket2.write(data)
      end
    rescue EOFError, SystemCallError
      STDLOG.info("exception: #{$!}")
      STDLOG.debug($!)
    ensure
      STDLOG.info("stop tunnel: #{addr1} -> #{addr2}")
      socket1.close_read
      socket2.close_write
    end
  }
end

watch_pid = Process.ppid
accept_polling_timeout_seconds = 0.1

opts = OptionParser.new
opts.banner = "Usage: #{File.basename($0)} [options] CONNECT_PATH LISTEN_PATH"
opts.on('-l', '--log-level=LEVEL', %w[ debug info warn error fatal ]) {|level|
  STDLOG.level = level
}
opts.on('-w', '--watch-pid=PID', Integer) {|pid|
  watch_pid = pid
}
opts.on('-t', '--accept-timeout=SECONDS', Float) {|timeout_seconds|
  accept_polling_timeout_seconds = timeout_seconds
}
opts.parse!

if (ARGV.length != 2) then
  puts opts.banner
  exit(1)
end

connect_socket_path = ARGV.shift
listen_socket_path = ARGV.shift

STDLOG.info("watch pid: #{watch_pid}")
STDLOG.info("accept polling timeout: #{accept_polling_timeout_seconds} s")

unless (File.socket? connect_socket_path) then
  STDLOG.fatal("not found a connect socket: #{connect_socket_path}")
  exit(1)
end

tunnel_thread_group = ThreadGroup.new
begin
  STDLOG.info("open listen socket: #{listen_socket_path}")
  server_socket = UNIXServer.new(listen_socket_path)
  catch(:end_of_tunnel) {
    while (true)
      until (server_socket.wait_readable(accept_polling_timeout_seconds) != nil)
        ping_process(watch_pid) or throw(:end_of_tunnel)
      end
      listen_socket = server_socket.accept
      connect_socket = UNIXSocket.new(connect_socket_path)
      tunnel_thread_group.add(start_tunnel(listen_socket, listen_socket.local_address.inspect_sockaddr,
                                           connect_socket, connect_socket.remote_address.inspect_sockaddr))
      tunnel_thread_group.add(start_tunnel(connect_socket, connect_socket.remote_address.inspect_sockaddr,
                                           listen_socket, listen_socket.local_address.inspect_sockaddr))
      ping_process(watch_pid) or throw(:end_of_tunnel)
    end
  }

  STDLOG.info("close listen socket: #{listen_socket_path}")
  server_socket.close

  STDLOG.info("wait to end of connections")
  for thread in tunnel_thread_group.list
    thread.join
  end

  STDLOG.info("end of tunnel")
rescue
  STDLOG.fatal($!)
  exit(1)
end

exit(0)

# Local Variables:
# mode: Ruby
# indent-tabs-mode: nil
# End:
